Features:
- Rewrite freeglut so that it's performant
    http://en.wikibooks.org/wiki/OpenGL_Programming
    - Then Change FreeGLUT to GLFW and use GLEW
    - Performance of tile text, fog, colors
- Figure out how to get rid of ifdefs
- Make a SimInterface and make sure it's easy to "extract" an algorithm for use on Arduino
- Updates on the tile boundaries, not centers
- Other mouse movements - curve turns, j-turns, diagonals, etc.
- Inconsistent wall declaration colors (one side of wall but not the other)
- Actual distance values on the tile
- Draw a path of where the robot has been (the history object could be used for recording as well)
- Shortest path graphic (phantom bot that travels along other shortest paths)
- Maze Validation (both physically valid mazes and competition valid mazes)
- MazeChecker class that hides the validation functions
- Randomly select a pre-defined maze
- Add support for multiple mouse starting locations (both left and right corner)
- Add support for maze rotation
- Buffer communication (like with the real robot)
- Data recording for pause, rewind, fast forward
- Interrupt interface
- Run the program with maximum thread priority
- New maze w/o restarting app
- Be able to restart in the middle of a run
- Make terminal style output at bottom or right of window (GUI)
- Indicator of sim speed (real time, 10x fast, etc.)
- Dual screen! (mini-map and zoomed-in view - 1x1, 3x3, relative and absolute rotation)
- Support stepper motor / encoders interface
- Sensor readings for walls other than front, left right
- Get Tomasz's random maze algorithm working
- Normalize random number generation (Implement Windows random number generation)
- Parameter for selecting a random maze file from the maze file directory
- Include Arduino "types" with the MouseInterface
- Crash animation for both modes
- Crash recovery semantics
- Reimplement drawPolygon to use a tesselator (so that it can draw non-convex polygons)
- Make a nice mechanism for writing our own maze generation algorithms
- Bluetooth connection to the actual mouse
- More Arduino function support
- Add Wheel max speed (specificed in mouse parameter file)
- Change over the Makefile to use cmake
- Add some nice LaTeX documentation
- Support more than two wheels (let's hold off on this for now...)
- In discrete mode, the mouse can overturn or go too far if the sim speed is to high. We need
to implement some logic that checks this ahead of time and then just teleports... sort of like
bullets in other physics simulators
- Add trajectory lines (see https://www.youtube.com/watch?v=kgJClVCPu3w)
- Add gridlines (see https://www.youtube.com/watch?v=LGRutv9cGBA and https://www.youtube.com/watch?v=gtnTBf5ItEc)

Clean-Up:
- Convert floats to doubles where appropriate
- Convert primitive types to GL types
- Return const references instead of values (pointers???)
- Change float to units (including in the ParamParser and Param class)
- Type safety (in terms of units) of the parameters
- Reduce includes as much as possible
- Rewrite the Makefile to use an "inc" directory
- Change "bool foo(false)" to "bool foo = false" for primitive - they look like function calls
- Handle bad values in the parameters, such as bad colors, negative values, etc.
- Put interface in root of src directory
- write "isDirectory(std::string path)" and enforce this where necessary
- write getRandom() and replace old calls to rand()
- Performance on different systems???
- The mouse sometimes rotates weirdly (goes slowly, backwards for a second, and then forwards fast.
    You can see what I mean by just increasing the view length of the sensors for a continuous algo)
- Remove as many c_str() as possible
- Replace "cout" with "print"
- Pass things by reference when possible
- Sprinkle assertions everywhere
- Validate the coding standards (especially "{" placement)
- Rewrite "i++" and "++i" as "i += 1"
- Give better explanations for the GeometryUtilities
- Change "AlgoWalls" to "DeclaredWalls" where appropriate
- Buffer the declared walls and include a quick "resetWalls()" method
- Change the Mouse to use the technically correct position update implementation
- Clean up / improve the coding standards
