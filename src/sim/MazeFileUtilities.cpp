#include "MazeFileUtilities.h"

#include <fstream>
#include <iostream>
#include <iterator>
#include <sstream>

#include "SimUtilities.h"

namespace sim {

std::pair<int, int> getMazeSize(std::string mazeFilePath) {

    // Note: This function should only be called on maze files that have been validated.
    // In particular, we assuming that the dimensions of the maze are given in the last,
    // line of the file, which might not be the case if the lines are properly sorted.

    // Read the last, non-empty line of the file
    std::ifstream file(mazeFilePath.c_str());
    std::string line("");
    std::string prevLine("");
    while (getline(file, line)) {
        if (!line.empty()) {
            prevLine = line;
        }
    }
    file.close();

    // Put the tokens in a vector
    std::istringstream iss(prevLine);
    std::vector<std::string> tokens;
    copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(),
         std::back_inserter<std::vector<std::string>>(tokens));

    // Extract the width and height values, adding 1 because we started counting at 0
    int width = strToInt(tokens.at(0)) + 1;
    int height = strToInt(tokens.at(1)) + 1;
    return std::make_pair(width, height);
}


// TODO
struct mazeTile { 
 
    int x_pos; 
    int y_pos; 
    int wallNorth; 
    int wallEast; 
    int wallSouth; 
    int wallWest; 
 
}; 

bool validMaze(std::string mazeFilePath) {

    // TODO: This should ensure a PHYSICALLY POSSIBLE MAZE
    // TODO: SOM
    // Format requires that:
    // - File exists
    // - The correct number of rows and columns
    // - rows and cols are in expected order
    // - The rows and columns labeled correctly
    // - Walls are all valid
    // - The maze is surrounded by walls
    // This means that the maze can be unsolvable and any size and shape

    // TODO: extract the width and height from the file

    // TODO: Do we want to perform maze validation on autogenerated mazes? probably, just for safe keeping and consistency

    // TODO: Function for specific rules
    // TODO: Maze validation - has a path to the center, no wall following robot, etc.

    // Create the file object
    // TODO: Take this out of the maze
    std::ifstream file(mazeFilePath.c_str());

    // Error opening file
    if (!file.is_open()) {
        // TODO: Is this really the best error message here...
        std::cout << "Invalid maze file: could not open \"" << mazeFilePath << "\"" << std::endl;
        return false;
    }

    // Initialize a string variable
    std::string line("");

    // Current x and y position
    int x = 0;
    int y = 0;

    // Overall width and height of the maze // TODO: Needed??
    int width = -1;
    int height = -1;

    std::vector<std::vector<mazeTile>> maze; // Store the values of the maze

    while (std::getline(file, line)) {

        // Extract the whitespace separated tokens
        std::vector<std::string> tokens = tokenize(line);

        // Check to see that there are exactly six entries...
        if (6 != tokens.size()) {
            // TODO: Print error strings
            return false;
        }

        // ... all of which are numeric
        for (int i = 0; i < tokens.size(); i += 1) {
            if (!isInt(tokens.at(i))) {
                // TODO: Print error strings
                return false;
            }
        }

        mazeTile tile;
        tile.x_pos = atoi(tokens.at(0).c_str()); // X position
        tile.y_pos = atoi(tokens.at(1).c_str()); // Y position
        tile.wallNorth = (1 == atoi(tokens.at(2).c_str())); // 1 if north wall, else 0
        tile.wallEast = (1 == atoi(tokens.at(3).c_str())); // 1 if  east wall, else 0
        tile.wallSouth = (1 == atoi(tokens.at(4).c_str())); // 1 if south wall, else 0
        tile.wallWest = (1 == atoi(tokens.at(5).c_str())); // 1 if  west wall, else 0

        // TODO: First, each line should have precisely six things
    }
    return true; //should be fine
}

} // namespace sim
